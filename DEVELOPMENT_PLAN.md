# 4) Порядок реализации для Codex

## Шаг 1. Добавить компоненты shadcn/ui

* [x] Убедиться, что shadcn/ui уже инициализирован в проекте.
* [x] Добавить компоненты:

```bash
npx shadcn@latest add sonner sheet button input select card accordion label
```

## Шаг 2. Подключить Sonner глобально

### Правка `app/layout.tsx`

* [x] Добавить `lang="ru"` в `<html>`.
* [x] Импортировать `Toaster` из `@/components/ui/sonner`.
* [x] Вставить `<Toaster />` в `body` (в конце), один раз.

Контроль:

* [x] Ни в одном месте не использовать `alert`.
* [x] Ошибки/успех показывать через `toast(...)` из `sonner`.

---

## Шаг 3. Создать каркас генератора (структура файлов)

Создать файлы:

* [x] `lib/random/prng.ts`
* [x] `lib/generators/task9/types.ts`
* [x] `lib/generators/task9/text.ts`
* [x] `lib/generators/task9/area.ts`
* [x] `lib/generators/task9/spokes.ts`
* [x] `lib/generators/task9/fence.ts`
* [x] `lib/generators/task9/validate.ts`
* [x] `lib/generators/task9/index.ts`

---

## Шаг 4. Описать типы (types.ts)

* [x] В `types.ts` создать:

```ts
export type Task9Subtype = "area" | "spokes" | "fence";
export type Difficulty = "easy" | "medium" | "hard";

export type Task = {
  id: string;
  number: 9;
  subtype: Task9Subtype;
  statement: string;           // обычный текст
  answer: string;              // только число (без единиц)
  steps: string[];             // обычный текст
  params: Record<string, number>;
};

export type GenerateOptions = {
  count: number;                       // 1..50
  subtype: "mixed" | Task9Subtype;
  difficulty: Difficulty;
  seed?: number;
};
```

---

## Шаг 5. Реализовать PRNG (prng.ts)

* [x] Реализовать `createPrng(seed: number)`:

  * `nextFloat(): number` → [0; 1)
  * `int(min,max): number`
  * `pick<T>(arr: T[]): T`

Контроль:

* [x] При одинаковом `seed` и одинаковых настройках набор задач повторяется.

---

## Шаг 6. Текстовые шаблоны (text.ts) — полностью, без разметки

**Запрет:** никакой разметки в строках (`**`, `\(...\)`, `\cdot` и т. п.). Только обычный русский текст и символы `·`, `−`, `:`.

В `text.ts` сделать функции, которые формируют `statement` и `steps`.

### area — текст

**statement:**
Дачный участок имеет форму прямоугольника, стороны которого равны {L} м и {W} м. Дом, расположенный на участке, на плане также имеет форму прямоугольника, стороны которого равны {a} м и {b} м. Найдите площадь оставшейся части участка, не занятой домом. Ответ дайте в квадратных метрах.

**steps:**

1. Площадь участка: Sуч = {L} · {W} = {L*W}.
2. Площадь дома: Sдом = {a} · {b} = {a*b}.
3. Свободная площадь: S = Sуч − Sдом = {L*W} − {a*b} = {answer}.
4. Ответ: {answer}.

### spokes — текст

**statement:**
Колесо имеет {n} спиц. Углы между любыми двумя соседними спицами равны. Найдите величину угла (в градусах), который образуют две соседние спицы.

**steps:**

1. Полный угол вокруг центра равен 360°.
2. Этот угол поделен на {n} равных частей.
3. Угол между соседними спицами: 360 : {n} = {answer}.
4. Ответ: {answer}.

### fence — текст

**statement:**
Участок земли имеет прямоугольную форму. Стороны прямоугольника равны {L} м и {W} м. Найдите длину забора (в метрах), которым нужно огородить участок, предусмотрев проезд шириной {g} м.

**steps:**

1. Периметр участка: P = 2 · ({L} + {W}) = 2 · {L+W} = {2*(L+W)}.
2. Проезд шириной {g} м — это разрыв в заборе длиной {g}.
3. Длина забора: P − {g} = {2*(L+W)} − {g} = {answer}.
4. Ответ: {answer}.

Контроль:

* [x] `answer` в задачах — только число, без единиц.

---

## Шаг 7. Генераторы трёх типов (area/spokes/fence)

Каждый генератор:

* [x] генерирует параметры в зависимости от `difficulty`
* [x] вычисляет `answer` (строкой)
* [x] берет `statement/steps` из `text.ts`
* [x] заполняет `params` исходными числами

### 7.1 area.ts (площадь)

* Диапазоны:

  * easy: `L,W` 20..60; `a,b` 4..15
  * medium: `L,W` 40..120; `a,b` 6..25
  * hard: `L,W` 80..250; `a,b` 10..60
* Ограничения (обязательные):

  * дом помещается с поворотом: `(a < L && b < W) || (a < W && b < L)`
  * `L*W - a*b > 0`
* Ответ: `String(L*W - a*b)`

### 7.2 spokes.ts (спицы)

* `n` брать из набора по сложности:

  * easy: `[6, 8, 9, 10, 12, 15, 18, 20, 24]`
  * medium: + `[30, 36, 40, 45, 60]`
  * hard: + `[72, 90, 120, 180]`
* Ограничения:

  * `n >= 3`
  * `360 % n === 0` (для наборов это уже выполняется)
* Ответ: `String(360 / n)`

### 7.3 fence.ts (забор)

* Диапазоны:

  * easy: `L,W` 20..80; `g` 2..6
  * medium: `L,W` 50..200; `g` 2..10
  * hard: `L,W` 100..500; `g` 3..20
* Ограничения:

  * `1 <= g < min(L, W)`
  * `2*(L+W) - g > 0`
* Ответ: `String(2*(L+W) - g)`

---

## Шаг 8. Валидация (validate.ts) + перегенерация

### validate.ts

* [x] Реализовать `validateTask(task: Task): void` с проверками:

**area:**

* помещается: `(a < L && b < W) || (a < W && b < L)`
* `L*W - a*b > 0`
* `answer === String(L*W - a*b)`

**spokes:**

* `n >= 3`
* `360 % n === 0`
* `answer === String(360 / n)`

**fence:**

* `1 <= g < min(L, W)`
* `2*(L+W) - g > 0`
* `answer === String(2*(L+W) - g)`

### Перегенерация

* [x] В процессе генерации одной задачи использовать `MAX_ATTEMPTS = 50`:

  * сгенерировать → собрать → валидировать
  * если не прошло — повторить
  * если исчерпано — выбросить ошибку

---

## Шаг 9. Общий генератор набора (index.ts)

* [x] Реализовать `generateTask9Set(options: GenerateOptions): Task[]`

Внутри:

* [x] Нормализовать `count`: целое, зажать 1..50.
* [x] Нормализовать `seed`: если NaN/пусто — считать “не задан”.
* [x] Создать `prng` на основе seed (или `Date.now()`).
* [x] Генерировать `count` задач:

  * если `subtype === "mixed"` — случайно выбирать один из трёх
  * иначе — строго выбранный тип
* [x] Генерировать `id`:

  * `crypto.randomUUID()` если доступно; иначе строка из `(seed||Date.now())`, индекса и типа.
* [x] Защита от дублей подряд:

  * хранить `lastStatement`
  * если совпало — перегенерировать (в рамках попыток)

---

## Шаг 10. UI-страница (app/page.tsx) — русский интерфейс + адаптивность

### Общие требования

* [x] В начале файла: `"use client"`
* [x] Все тексты на русском.
* [x] Все сообщения только через `toast(...)` из `sonner`.

### Состояния

* [x] `count`, `subtype`, `difficulty`, `seed`
* [x] `tasks: Task[]`
* [x] `sheetOpen` (для мобильного режима)

### Валидация ввода на UI

* [x] Если `count` некорректен → `toast("Некорректное количество задач")` и остановить.
* [x] Если `seed` заполнен, но некорректен → `toast("Некорректное начальное число")` и остановить **или** игнорировать seed (выбрать один вариант и придерживаться везде). Рекомендация: остановить и попросить исправить.

### Макет `< lg`

* [x] Верхняя строка:

  * Заголовок “Генератор задания 9”
  * Кнопка `Button` “Настройки”
* [x] `Sheet`:

  * внутри `Card`/блок с полями (Label+Input/Select)
  * кнопка “Сгенерировать”
* [x] После успешной генерации:

  * закрыть Sheet
  * `toast("Сгенерировано: N")`

### Макет `lg+`

* [x] `grid` с двумя колонками:

  * слева `Card` “Настройки” (опционально `sticky top-4`)
  * справа список задач
* [x] Кнопка “Сгенерировать” в левом блоке
* [x] `toast("Сгенерировано: N")` при успехе

### Карточки задач

* [x] Каждая задача — `Card`:

  * Заголовок: “Задание 9 — Площадь/Спицы/Забор”
  * `statement`
  * `Accordion` с 2 секциями:

    * “Ответ” → показывает `answer`
    * “Решение” → показывает `steps` как нумерованный список
* [x] (Опционально) `Button` “Скопировать ответ”:

  * копировать `answer` в буфер
  * `toast("Ответ скопирован")` / `toast("Не удалось скопировать")`

### Обработка ошибок генерации

* [x] Обернуть генерацию в `try/catch`:

  * при ошибке `toast("Не удалось сгенерировать набор. Измените настройки.")`
  * не падать страницей

---

## Шаг 11. Правило десятичной запятой (на будущее)

* [x] Добавить утилиту `formatNumberRu` и комментарий: если появятся дроби, использовать запятую (`0,6`).

---

# 5) Финальная проверка (приёмка)

* [x] Генерируется ровно N задач.
* [x] Выбранный тип генерирует только этот тип, “Смешанный” даёт смесь.
* [x] Одинаковый seed даёт одинаковый набор при тех же настройках.
* [x] `answer` везде только число, без единиц.
* [x] Решение совпадает с вычислениями из `params`.
* [x] На телефоне/планшете настройки в Sheet, на компьютере — слева в колонке.
* [x] Все ошибки/уведомления идут только через Sonner.

---

## Проверка “ничего не забыто”

В плане присутствуют: цель и результат, 3 типа задач, правила ответа, русский UI, адаптивные макеты, список компонентов, команды shadcn, подключение Sonner в layout, структура файлов, PRNG, тексты условий и решений, генераторы, валидация, перегенерация, защита от дублей, UI-логика, обработка ошибок, приёмка.
